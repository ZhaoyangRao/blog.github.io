(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{180:function(e,n,s){"use strict";s.r(n);var t=s(0),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[s("strong",[e._v("模块化")])]),e._v(" "),s("p",[e._v("随着前端的系统越来越复杂，开发者要维护大量的代码，这时候很自然的就需要把系统功能依赖等等隔离，分成模块组织复杂的代码")]),e._v(" "),s("p",[e._v("在没有模块化之前，开发者都是通过编码模拟出类似模块的的功能例如函数封装，对象封装等等来避免变量污染，命名冲突等等。但随着代码量复杂度的提升，代码的可读性，可扩展，复用都靠开发者自己的约束显然是行不通的，很自然需要一套模块化规范。")]),e._v(" "),s("h2",{attrs:{id:"模块化规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化规范"}},[e._v("#")]),e._v(" 模块化规范")]),e._v(" "),s("p",[e._v("常见的模块化规范CommonJS,AMD,CMD,ES6模块化等等")]),e._v(" "),s("h3",{attrs:{id:"commonjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),s("p",[e._v("CommonJS其实是服务器的模块化规范，我们熟悉的nodejs就是采用这个规范"),s("br"),e._v("\n每个文件都是一个模块，加载模块用require，暴露模块用exports，很多模块化规范都复用了这两个关键字")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("定义模块\na.js\nfunction a(){    \n}\nexports.a=a\nor\nmodule.exports=a\n————————————————————————————————————————————————————————————————————\n\n引用模块\nb.js\nvar a=require('./a.js')\n\n")])])]),s("p",[e._v("因为服务器通常情况下文件模块都是在本地，所以commonjs规范是同步的规范，并没有考虑异步，而其实我们浏览器环境，是需要从服务器加载模块的，就必须考虑异步，所以也就诞生了异步模块化规范")]),e._v(" "),s("h3",{attrs:{id:"amd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" AMD")]),e._v(" "),s("p",[e._v("AMD就是典型的异步规范，是RequireJS在推广过程中对模块化定义的产出")]),e._v(" "),s("p",[e._v("关键字define定义模块")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("定义模块\n\n//If the module does not have dependencies\ndefine(function () {\n    //Do setup work here\n    return {\n        color: \"black\",\n        size: \"unisize\"\n    }\n});\n\n//If the module has dependencies\ndefine(['./a.js','./b.js'],function(a,b){\nreturn {\n        color: \"blue\",\n        size: \"large\",\n        addToCart: function() {\n            a.decrement(this);\n            b.add(this);\n        }\n}\n})\n————————————————————————————————————————————————————————————————————\n引用模块\nrequirejs.config({\n    baseUrl: 'js/lib',\n    paths: {\n        jquery:['../lib/jquery']\n    }\n});\n//Later\nrequirejs(['jquery'], function ($) {\n    //can be used here\n});\n")])])]),s("h3",{attrs:{id:"cmd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),s("p",[e._v("CMD同样也是sea.js推广过程中对模块化定义的产出")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('定义模块\ndefine(function(require,exports,module){\n    var a=require(\'./a.js\')\n    var b=require(\'./b.js\')\n    \n    // 通过 exports 对外提供接口\n    exports.doSomething = ...\n})\n————————————————————————————————————————————————————————————————————\n\n引用模块\n// seajs 的简单配置\nseajs.config({\n  base: "../sea-modules/",\n  alias: {\n    "jquery": "jquery/jquery/1.10.1/jquery.js"\n  }\n});\n\n// 加载入口模块\nseajs.use("../static/hello/src/main");\n')])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("AMD与CMD异同")]),e._v(" "),s("p",[e._v("从代码书写的表现可以明显看到AMD是需要define的时候就要定义用到哪些模块，而CMD则是在回调里面引用模块")]),e._v(" "),s("ul",[s("li",[e._v("AMD依赖前置 CMD依赖就近")]),e._v(" "),s("li",[e._v("按照基础推荐示例AMD提前执行(其实AMD新版本也可以支持类似CMD的书写方式了，引入一个require模块)，CMD会用到才会执行")])])]),e._v(" "),s("h3",{attrs:{id:"es6模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6模块化"}},[e._v("#")]),e._v(" es6模块化")]),e._v(" "),s("p",[e._v("前面提到的模块化规范都是各个团队非正式推广诞生的规范，而es6则是在js语言的标准层面上，实现模块的功能，并且非常简单，完全可以替代以往的规范")]),e._v(" "),s("p",[e._v("关键字：import export")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('定义模块\nexport function multiply() {...};\nexport var year = 2018;\nexport default ...\n\n引用模块\nimport "/app";\nimport React from “react”;\nimport { Component } from “react”;\n')])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("设计思想")]),e._v(" "),s("p",[e._v("es6的模块思想与以往最大的区别就是，静态分析，即在编译的时候就确定模块的依赖关系，而Commonjs AMD都是执行的时候才能确定。"),s("br"),e._v("\n因为es6更强调的是静态分析，所以import关键字引入的模块都是写在代码的最前面，模块地址不能用变量代替，并且还会变量提升，同时无法对其进行逻辑判断等等，总之原则就是静态分析，要动态的引用就用  require。")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// case 1\nif (bool) {\n  require('./foo')()\n} else {\n  require('./bar')()\n}\n\n// case 2\nfor (const item of list) {\n  require(`./foo-${item}`)()\n}\n\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);