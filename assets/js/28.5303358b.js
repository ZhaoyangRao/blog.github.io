(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{167:function(t,e,a){"use strict";a.r(e);var n=a(0),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),a("p",[t._v("http(超文本传输协议)是基于TCP/IP协议的应用层协议，主要是规定客服端与服务端通信的规则，协议，默认80端口。")]),t._v(" "),a("h3",{attrs:{id:"http0-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http0-9"}},[t._v("#")]),t._v(" http0.9")]),t._v(" "),a("p",[t._v("最早的0.9版本，只有一个GET命令，而且协议规定服务端只能返回HTML格式的字符串。")]),t._v(" "),a("h4",{attrs:{id:"客户端请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端请求"}},[t._v("#")]),t._v(" 客户端请求")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET /index.html\n")])])]),a("h4",{attrs:{id:"服务端响应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端响应"}},[t._v("#")]),t._v(" 服务端响应")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<html>\n  <body>Hello World</body>\n</html>\n")])])]),a("h3",{attrs:{id:"http1-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[t._v("#")]),t._v(" http1.0")]),t._v(" "),a("p",[t._v("1.0版本的发布极大的丰富了http协议")]),t._v(" "),a("ul",[a("li",[t._v("各种格式的内容都可以传输，图片，音频，文字")]),t._v(" "),a("li",[t._v("命令GET POST，还有HEAD命令")]),t._v(" "),a("li",[t._v("状态码，缓存，权限，内容编码，头信息等等新增的概念")])]),t._v(" "),a("h4",{attrs:{id:"客户端请求-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端请求-2"}},[t._v("#")]),t._v(" 客户端请求")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET / HTTP/1.0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: */*\n")])])]),a("h4",{attrs:{id:"服务端响应-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端响应-2"}},[t._v("#")]),t._v(" 服务端响应")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("HTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n<html>\n  <body>Hello World</body>\n</html>\n")])])]),a("h4",{attrs:{id:"content-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#content-type"}},[t._v("#")]),t._v(" Content-Type")]),t._v(" "),a("p",[t._v("主要是指数据的格式，服务端告诉客户端传给你的数据是什么格式，你可以看见Content-Type字段后面的值")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("text/plain\ntext/html\ntext/css\nimage/jpeg\nimage/png\nimage/svg+xml\naudio/mp4\nvideo/mp4\napplication/javascript\napplication/pdf\napplication/zip\napplication/atom+xml\n")])])]),a("h4",{attrs:{id:"content-encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#content-encoding"}},[t._v("#")]),t._v(" Content-Encoding")]),t._v(" "),a("p",[t._v("主要是用来表示数据的压缩的方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Content-Encoding: gzip\nContent-Encoding: compress\nContent-Encoding: deflate\n\n")])])]),a("p",[t._v("可以看到http1.0已经能够压缩传输的数据，并且传输数据支持的格式更多，最大的缺点就是每次请求都会新建一个tcp连接，无法复用。")]),t._v(" "),a("p",[t._v("于是部分浏览器在请求时，新增了一个非标准的Connection: keep-alive，意思就是告诉服务端不要关闭这个TCP，其他请求可以复用，服务端同时也会回应该字段，但是这个并不是所有的浏览器都会支持，于是诞生了http1.1")]),t._v(" "),a("h3",{attrs:{id:"http1-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" http1.1")]),t._v(" "),a("h4",{attrs:{id:"持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久连接"}},[t._v("#")]),t._v(" 持久连接")]),t._v(" "),a("p",[t._v("http1.1最大的新增功能亮点就是引入了持久连接，tcp默认不会关闭，请求的时候不设置默认就Connection: keep-alive。")]),t._v(" "),a("p",[t._v("客户端服务端经过过一段时间没有活动会自动关闭该tcp连接，或者可以设置Connection: close主动关闭tcp连接")]),t._v(" "),a("p",[t._v("当然同域名浏览器的持久连接数量是有限制的，不同的浏览器支持的个数可能不太一样")]),t._v(" "),a("h4",{attrs:{id:"管道机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管道机制"}},[t._v("#")]),t._v(" 管道机制")]),t._v(" "),a("p",[t._v("同时http1.1还新增了管道机制的概念，简单的理解,tcp就像一个管道，管道里面可以同时发起多个请求，但是注意的是在同一个tcp连接里面的多个请求，服务器会按照请求的顺序依次返回结果")]),t._v(" "),a("h4",{attrs:{id:"content-length"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#content-length"}},[t._v("#")]),t._v(" Content-Length")]),t._v(" "),a("p",[t._v("在http1.0，Content-Length这个字段其实用处可能就是表示这个包的大小，而在1.1里面这个字段还有另外一个重要的作用，我们知道1.1的管道机制，同一个tcp可以发起几个请求，那么到底是怎么区分返回的数据是哪一个请求的呢？这就是Content-Length的作用了，当包的大小与Content-Length相等，那么这个请求的包就结束了，接下来的就是下一个请求的数据了")]),t._v(" "),a("h4",{attrs:{id:"分块传输编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分块传输编码"}},[t._v("#")]),t._v(" 分块传输编码")]),t._v(" "),a("h4",{attrs:{id:"host"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#host"}},[t._v("#")]),t._v(" Host")]),t._v(" "),a("p",[t._v("这个字段的最重要的作用就是，有了这个字段我们就可以把我们的请求发往指定的域名。\n这样同一个服务器就可以部署多个不同的域名")]),t._v(" "),a("p",[t._v('1.1也是目前很主流的版本，新增了很多功能，但是同时随着互联网的发展，对网页响应交互要求越来越高，数据量也越来越大，虽然1.1允许tcp复用，但是管道机制又会按序返回结果，如果前面一个堵塞，后面的就没法完了，这称为"队头堵塞"，尤其现在对网页首页渲染时间的要求容忍度越来越低')]),t._v(" "),a("p",[t._v("1.1版本现在大部分前端的优化都是要么减少请求，要么就同时多开tcp连接，比如www.img1.com www.img2.com等等")]),t._v(" "),a("h3",{attrs:{id:"spdy协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spdy协议"}},[t._v("#")]),t._v(" SPDY协议")]),t._v(" "),a("p",[t._v("谷歌针对1.1做的优化，自行发布的SPDY协议，所以兼容性肯定是存在问题的，但是它为http2提供了很多借鉴意义，甚至很多功能其实都很相似。")]),t._v(" "),a("ul",[a("li",[t._v("请求优先级\n在1.1版本虽然有管道机制的概念，但都是顺序返回的，并没有请求优先级的概念，有了请求优先级，就可以让重要的请求优先处理。")]),t._v(" "),a("li",[t._v("服务端推送\n在1.1以前都是由客户端推送到服务端，而SPDY协议允许服务端推送到客户端")]),t._v(" "),a("li",[t._v("header压缩\n1.1以前可以对传输的数据压缩，但并没有对header压缩的概念，随着发展，其实header的内容越来越丰富，自定义的字段也越来越多，比如每次请求都带上cookie.token等，对header的压缩自然能减少包的大小和传输速度")]),t._v(" "),a("li",[t._v("加密传输\n基于https的加密协议传输，更加安全")]),t._v(" "),a("li",[t._v("多路复用\n1.1同一条TCP的持久连接数量是有限制的，但SPDY多路复用简单的理解就是同一条TCP可以无限制处理多条http请求")])]),t._v(" "),a("p",[t._v("SPDY协议最大的缺点就是很多浏览器其实并不支持，服务端也需要改造来支持它")]),t._v(" "),a("h3",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),a("p",[t._v("WebSocket协议已经成为一种国际标准，基本所有的主流浏览器都支持，它最大的功能就是实现了服务端与客户端相互通信，最大的应用场景就是聊天室，如果你用传统的http1.1以前的版本，那就只能定时向服务端发起请求")]),t._v(" "),a("ul",[a("li",[t._v("依然是建立在tcp协议上")]),t._v(" "),a("li",[t._v("发送的数据可以是文本也可以是二进制")]),t._v(" "),a("li",[t._v("没有同源的限制")]),t._v(" "),a("li",[t._v("协议的标识符是ws，加密则是wss")])]),t._v(" "),a("p",[t._v("其实前端使用起来也很简单，下面是一个简单的示例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 新建 WebSocket 实例\nvar ws = new WebSocket("wss://echo.websocket.org");\n//返回实例对象的当前状态\nswitch (ws.readyState) {\n  case WebSocket.CONNECTING:\n    // do something\n    break;\n  case WebSocket.OPEN:\n    // do something\n    break;\n  case WebSocket.CLOSING:\n    // do something\n    break;\n  case WebSocket.CLOSED:\n    // do something\n    break;\n  default:\n    // this never happens\n    break;\n}\n\n//指定连接成功后的回调函数\nws.onopen = function(evt) { \n  console.log("Connection open ..."); \n  ws.send("Hello WebSockets!");\n};\n\n//接收服务器数据后的回调函数\nws.onmessage = function(evt) {\n  console.log( "Received Message: " + evt.data);\n  ws.close();\n};\n\n//向服务器发送信息\nws.send(\'your message\');\n\n//连接关闭后的回调函数\nws.onclose = function(evt) {\n  console.log("Connection closed.");\n};      \n')])])]),a("h3",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" http2")]),t._v(" "),a("p",[t._v("就像前面说的http2其实很多功能跟SPDY很相似")]),t._v(" "),a("ul",[a("li",[t._v("多工")])]),t._v(" "),a("p",[t._v("在http2，同一个TCP连接可以同时发起多个请求和回应，最重要的是我们知道1.1以前的版本都是按序返回，而2版本并不用按顺序返回，也就避免了队头堵塞")]),t._v(" "),a("p",[t._v("在一个tcp连接里面同时发起多个请求，如果发现某个请求回应很堵塞，把处理好的部分继续发送，接着就发送其他请求，完成后再把堵塞的请求剩余的发送了，这样双向的实时的通信就叫做多工")]),t._v(" "),a("ul",[a("li",[t._v("二进制协议")])]),t._v(" "),a("p",[t._v("http1.1数据体可以是文本也可以是二进制，头信息是文本。而http2则统一化了，统一用二进制，头信息和数据体都是二进制，统称为帧")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("数据流")]),t._v(" "),a("p",[a("em",[t._v("1.区分不同的包")])]),t._v(" "),a("p",[t._v("因为多工，http2不按顺序返回，而且同一个tcp连接有多条回应，那么怎么去区分是不同的包呢？"),a("br"),t._v("\nhttp2提出了数据流的概念，每个请求或者回应的都是一个数据流，每个数据流都有一个特殊的编号ID，相当于一个tag，这样就可以区分不同的数据流了。")]),t._v(" "),a("p",[a("em",[t._v("2.设定优先级")])]),t._v(" "),a("p",[t._v("当然也可以指定数据流的优先级，优先级越高，服务器就越早回应。")]),t._v(" "),a("p",[a("em",[t._v("3.取消发送和回应")])]),t._v(" "),a("p",[t._v("在1.1以前都是通过关闭tcp连接来取消发送的，而数据流发送到中途，服务端和客户端都可以发送信号（RST_STREAM帧）来取消这一次的请求，而不用关闭TCP连接")])]),t._v(" "),a("li",[a("p",[t._v("header压缩")])])]),t._v(" "),a("p",[t._v("http协议是不带状态的，每次请求都需要携带一些标识例如cookie等。\nhttp2版本引入了头信息压缩机制。\n客户端服务端还同时维护头信息，生成了索引号，相同域的请求就只发送索引了而不用再附加那些头信息了")]),t._v(" "),a("ul",[a("li",[t._v("服务器推送")])]),t._v(" "),a("p",[t._v("http2允许服务器主动推送到客户端，但是通常都是静态资源的推送，比如这个html其实包含很多静态资源，通常都是客户端收到html再解析，再发出资源请求，而http2就可以直接主动把相关资源一起发送给客户端")])])}),[],!1,null,null,null);e.default=s.exports}}]);