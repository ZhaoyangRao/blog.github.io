<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react | RaoCy</title>
    <meta name="description" content="欢迎来到RaoCy博客">
    <link rel="icon" href="/blog.github.io/images/logo.png">
    
    <link rel="preload" href="/blog.github.io/assets/css/0.styles.59e117d8.css" as="style"><link rel="preload" href="/blog.github.io/assets/js/app.bba64067.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/2.bc234928.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/13.51657757.js" as="script"><link rel="prefetch" href="/blog.github.io/assets/js/10.cbc3757b.js"><link rel="prefetch" href="/blog.github.io/assets/js/11.461a49a9.js"><link rel="prefetch" href="/blog.github.io/assets/js/12.3385b74f.js"><link rel="prefetch" href="/blog.github.io/assets/js/14.967341a4.js"><link rel="prefetch" href="/blog.github.io/assets/js/15.e94307c4.js"><link rel="prefetch" href="/blog.github.io/assets/js/16.d546238d.js"><link rel="prefetch" href="/blog.github.io/assets/js/17.5f06d85e.js"><link rel="prefetch" href="/blog.github.io/assets/js/18.fde54744.js"><link rel="prefetch" href="/blog.github.io/assets/js/19.f5a97b3c.js"><link rel="prefetch" href="/blog.github.io/assets/js/20.eb46622a.js"><link rel="prefetch" href="/blog.github.io/assets/js/21.e4fc2e78.js"><link rel="prefetch" href="/blog.github.io/assets/js/22.85db6c42.js"><link rel="prefetch" href="/blog.github.io/assets/js/23.91b626a7.js"><link rel="prefetch" href="/blog.github.io/assets/js/24.04204a0e.js"><link rel="prefetch" href="/blog.github.io/assets/js/25.44235572.js"><link rel="prefetch" href="/blog.github.io/assets/js/26.936cd153.js"><link rel="prefetch" href="/blog.github.io/assets/js/27.220e5385.js"><link rel="prefetch" href="/blog.github.io/assets/js/28.6b654efd.js"><link rel="prefetch" href="/blog.github.io/assets/js/29.87fd0e12.js"><link rel="prefetch" href="/blog.github.io/assets/js/3.81a9b252.js"><link rel="prefetch" href="/blog.github.io/assets/js/30.0e27fea2.js"><link rel="prefetch" href="/blog.github.io/assets/js/4.11c97c33.js"><link rel="prefetch" href="/blog.github.io/assets/js/5.9be0316a.js"><link rel="prefetch" href="/blog.github.io/assets/js/6.0ab42dfa.js"><link rel="prefetch" href="/blog.github.io/assets/js/7.5cca9709.js"><link rel="prefetch" href="/blog.github.io/assets/js/8.71614664.js"><link rel="prefetch" href="/blog.github.io/assets/js/9.07c23159.js">
    <link rel="stylesheet" href="/blog.github.io/assets/css/0.styles.59e117d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog.github.io/" class="home-link router-link-active"><!----> <span class="site-name">RaoCy</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>react</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog.github.io/react/#reactjs" class="sidebar-link">reactjs</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.github.io/react/#reactjs与vue" class="sidebar-link">reactjs与vue</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.github.io/react/#node环境-create-react-app" class="sidebar-link">node环境 create-react-app</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.github.io/react/#reactjs基本技术栈" class="sidebar-link">reactjs基本技术栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.github.io/react/#reactjs-2" class="sidebar-link">reactjs</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> react</h1> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>用于构建用户界面的 JavaScript 库
reactjs react-native</p></div> <p>这里先介绍react
由于公司内部技术栈基本为vue，本文主要是向公司内部实习生简单科普react自己编写的简单资料</p> <h2 id="reactjs"><a href="#reactjs" class="header-anchor">#</a> reactjs</h2> <p>官网https://react.docschina.org/</p> <h2 id="reactjs与vue"><a href="#reactjs与vue" class="header-anchor">#</a> reactjs与vue</h2> <p>技术无好坏，无比较，看自己选择，都是很成熟的前端框架，技术选型根据自己公司来选择</p> <h2 id="node环境-create-react-app"><a href="#node环境-create-react-app" class="header-anchor">#</a> node环境 create-react-app</h2> <p>至于用npm yarn看自己了，我选择的还是npm<br>
当然可以直接cdn html引入的方式玩，我这里直接选择官方脚手架create-react-app直接走起</p> <h2 id="reactjs基本技术栈"><a href="#reactjs基本技术栈" class="header-anchor">#</a> reactjs基本技术栈</h2> <p>reactjs react-router redux(mobx) axios webpack</p> <h3 id="reactjs-2"><a href="#reactjs-2" class="header-anchor">#</a> reactjs</h3> <h4 id="reactdom"><a href="#reactdom" class="header-anchor">#</a> ReactDOM</h4> <p>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</p> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.render(
&lt;p&gt;我是呗插入的模板组件&lt;/p&gt;, document.getElementById('app')
)
</code></pre></div><h4 id="jsx语法"><a href="#jsx语法" class="header-anchor">#</a> jsx语法</h4> <p>有点像js和xml结合混写，简单的说react支持在js里面直接写html，有自己的语法规范去解析，比如遇到&lt;这个标签它就用html规则去解析了，如果遇到{}就用js去解析</p> <div class="language- extra-class"><pre class="language-text"><code>var test='解析我吧，我是个变量'
ReactDOM.render(
&lt;p&gt;{test}&lt;/p&gt;, document.getElementById('app')
)
</code></pre></div><h4 id="component-fragment"><a href="#component-fragment" class="header-anchor">#</a> Component Fragment</h4> <div class="language- extra-class"><pre class="language-text"><code>//在create-react-app的.js文件
 import React,{Component,Fragment} from 'react'
 这里用了解构其实等价于
 import React from React;
 const Component =React.Component;
const Fragment =React.Fragment;
 引入了react和全局定义了Component，在组件里面可以看到大量的extends Component,这就是react的核心=&gt;Component（组件）
class App extends Component{
 render(){
  return(
  &lt;Fragment&gt;
    &lt;div className='my-div'&gt;
        &lt;span&gt;123&lt;/span&gt;
    &lt;/div&gt;
    &lt;/Fragment&gt;
  )
  //其实等价于
  //var spanN=React.createElement('span',null,'123')
  //var divN=React.createElement('div',{className:'my-div'},spanN)
 }
}
</code></pre></div><p>值得注意的是在react里面的一些小规范</p> <div class="language- extra-class"><pre class="language-text"><code>1.自定义组件&lt;App&gt; 大写开头
2.class=&gt;className
3.组件外面包裹一层，你可以用Fragment也可以用常用的标签，这个就跟vue template,angular的 ag-container一样
</code></pre></div><h4 id="es6"><a href="#es6" class="header-anchor">#</a> es6</h4> <p>react里面大量的es6语法，</p> <div class="language- extra-class"><pre class="language-text"><code>解构
箭头函数
class extends
import  exports
constructor
super
const let
扩展运算符
reduce filter
等等

</code></pre></div><h4 id="react的响应式设计与虚拟dom"><a href="#react的响应式设计与虚拟dom" class="header-anchor">#</a> react的响应式设计与虚拟DOM</h4> <pre><code>其实这个目前三大响应式框架vue react 差不多,具体的官网解释的也挺清楚的，框架只是工具，最主要的是你的编程思想，数据驱动，不再是jq时代的节点操作
</code></pre> <h4 id="state-setstate"><a href="#state-setstate" class="header-anchor">#</a> state setState</h4> <p>类似于vue中的data,不同的是react的单项数据流做的比较干净</p> <div class="language- extra-class"><pre class="language-text"><code>class App extend Component{
    constructor(props){
                super(props)
                this.state={
                  valueInput:'123'
                }
            }
    //console.log(this) 
    render(){
        return(
            &lt;Fragment&gt;
                &lt;input value={this.state.valueInput} onChange={this.handelInput.bind(this)}/&gt;
            &lt;/Fragment&gt;
        )
    }
    //这里就可以写方法了，vue methods
    handelInput(e){
        console.log(e.target.value)
        //this.state.valueInput=e.target.value 你想太多了
        this.setState({
        valueInput:e.target.value
        })
    }
    
}
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>1.单项数据流<br>
2.改变state 要用setState方法<br>
3.绑定事件，onClick小驼峰<br>
4.注意this指向绑定<br>
5.数组对象setState前，官方推荐先浅拷贝(这个坑很容易踩到，因为不会报错，程序执行正常，但会出现性能问题)</p></div> <h4 id="vue-v-for-pk-react-jsx循环"><a href="#vue-v-for-pk-react-jsx循环" class="header-anchor">#</a> vue v-for PK react jsx循环</h4> <p>react一种典型的js加xml的写法就体现出来了，简单粗暴</p> <div class="language- extra-class"><pre class="language-text"><code>class App extend Component(
    constructor(props){
      super(props)
      this.state={
        list:[11,22,33]
      }
    }
    render(){
        return(
             &lt;Fragment&gt; 
                {this.state.list.map((item,index)=&gt;{
                    return(
                        &lt;li key={index}&gt;{item}&lt;/li&gt;
                    )
                })}
             &lt;/Fragment&gt;
        )
    }
)
</code></pre></div><h4 id="vue-v-if-pk-react-jsx判断"><a href="#vue-v-if-pk-react-jsx判断" class="header-anchor">#</a> vue v-if PK react jsx判断</h4> <p>同理vue中的v-if，react写起来就更加随心所欲了，你可以把数据处理完传给它渲染，也可以在render函数里面直接jsx语法一套秒</p> <div class="language- extra-class"><pre class="language-text"><code>class App extend Component(
    constructor(props){
      super(props)
      this.state={
        list:[11,22,33]
      }
    }
    render(){
        return(
             &lt;Fragment&gt; 
                {this.state.list.map((item,index)=&gt;{
                    if(index&gt;1){
                        return(
                            &lt;li key={index}&gt;{item}&lt;/li&gt;
                        )
                    }else{
                        return(
                            &lt;li key={index}&gt;{item}&lt;/li&gt;
                        )
                    }
                    
                })}
             &lt;/Fragment&gt;
        )
    }
)
</code></pre></div><h4 id="vue中的v-html-pk-dangerouslysetinnerhtml"><a href="#vue中的v-html-pk-dangerouslysetinnerhtml" class="header-anchor">#</a> vue中的v-html PK dangerouslySetInnerHtml</h4> <p>为什么前面是dangerous？？？危险？？我推测是react想说哥们你想一下有没有必要这样操作，类似于操作节点耶</p> <div class="language- extra-class"><pre class="language-text"><code>class App extend Component(
    constructor(props){
      super(props)
      this.state={
        hone:'&lt;h1&gt;标题字体&lt;/h1&gt;'
      }
    }
    render(){
        return(
             &lt;Fragment&gt; 
                &lt;div  dangerouslySetInnerHtml={{_html:this.state.hone}}&gt;               
                &lt;/div&gt;
             &lt;/Fragment&gt;
        )
    }
)
</code></pre></div><p>为毛这里{{}}不要有疑问，因为{html:xxx}里面是一个对象呀</p> <h4 id="htmlfor-pk"><a href="#htmlfor-pk" class="header-anchor">#</a> htmlFor PK <label for="xxx"></label></h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;lable for='nextInput'&gt;点我就让id='nextInput'的input获取了焦点&lt;/label&gt;
&lt;input id='nextInput'/&gt;

react中
&lt;lable htmlFor='nextInput'&gt;点我就让id='nextInput'的input获取了焦点&lt;/label&gt;
&lt;input id='nextInput'/&gt;
</code></pre></div><p>为什么又这样？你要理解人家，for也是关键字啊，莫比比</p> <h4 id="标签的class"><a href="#标签的class" class="header-anchor">#</a> 标签的class</h4> <p>这里要说的是css里面的class,在react里面是className,为啥这么做，因为class这是个关键字啊=&gt;class extends</p> <h4 id="simple-react-snippets"><a href="#simple-react-snippets" class="header-anchor">#</a> simple react snippets</h4> <p>我碰巧看见别人快捷生成了一些例如下面这些基本常用的代码，几个单词就生成下面的代码，第一次看见，心中只有两个字无情，好在我的subline也能安装</p> <div class="language- extra-class"><pre class="language-text"><code>imrc 回车=&gt;
import React,{Component} from 'react'
cc 回车=&gt;
class App extends Component{
    constructor(props){
      super(props)
      this.state={
      }
      }
     render(){
      return(
      )
 
 }
}
}
</code></pre></div><h4 id="react-component组件"><a href="#react-component组件" class="header-anchor">#</a> react Component组件</h4> <p>其实vue跟react Component组件思想都一样，万物皆组件，一个网页就是很多组件组合起来的，各种组件的组合成各种各样的组件，像斗积木一样开心。</p> <div class="language- extra-class"><pre class="language-text"><code>子组件
class Son extends Component{
    constructor(props){
      super(props)
      this.state={
      }
      }
     render(){
      return(
       &lt;Fragment&gt; 
                &lt;div&gt;      
                我是son的文字哦
                &lt;/div&gt;
         &lt;/Fragment&gt;
      )
 
 }
}
}
exports default Son
父组件
import Son from './Son'
class App extends Component{
    constructor(props){
      super(props)
      this.state={
      }
      }
     render(){
      return(
           &lt;Fragment&gt; 
                &lt;Son/&gt;
            &lt;/Fragment&gt;
       
      )
 }
}
}
</code></pre></div><p>注意的是：
react的自定义组件有自己的语法</p> <h4 id="vue-pk-react组件传值"><a href="#vue-pk-react组件传值" class="header-anchor">#</a> vue PK react组件传值</h4> <p>//props传值</p> <div class="language- extra-class"><pre class="language-text"><code>父组件
import Son from './Son'
class App extends Component{
    constructor(props){
      super(props)
      this.state={
        setSon:'12'
      }
      }
     render(){
          return(
                &lt;Fragment&gt; 
                    &lt;Son setSon={this.state.setSon}/&gt;
                &lt;/Fragment&gt;

          )
 }
}

子组件
class Son extends Component{
    constructor(props){
      super(props)
      this.state={
      }
      }
     render(){
          return(
               &lt;Fragment&gt; 
                        &lt;div&gt;      
                         {this.props.setSon}
                        &lt;/div&gt;
                &lt;/Fragment&gt;
          )
 
     }
    }

exports default Son
</code></pre></div><p>// 子组件通知父组件改值</p> <div class="language- extra-class"><pre class="language-text"><code>父组件
import Son from './Son'
class App extends Component{
    constructor(props){
      super(props)
      this.state={
        setSon:'12'
      }
      }
     render(){
          return(
                &lt;Fragment&gt; 
                    &lt;Son setSon={this.state.setSon} changeData={this.changeData.bind(this)}/&gt;
                &lt;/Fragment&gt;

          )
     }
     changeData(){
         this.setState({
          setSon:'改了'
         })
     }
}
子组件
class Son extends Component{
    constructor(props){
      super(props)
      this.state={
      }
      }
     render(){
          return(
               &lt;Fragment&gt; 
                        &lt;div onClick={this.setParents.bind(this)}&gt;      
                         {this.props.setSon}
                        &lt;/div&gt;
                &lt;/Fragment&gt;
          )
 
     }
     setParents(){
        console.log(this.props)
        this.props.changeData()
     }
    }
exports default Son
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>1.父传子=&gt;通过props自定义属性去传递值或者方法给子组件<br>
2.子通知父=&gt;父组件将自己的方法传递给子组件,子组件通知父组件调用父组件自己的方法去改父组件的值，因为父组件改了自己的值从而让子组件数据变化<br>
3.当然跟vue一样父子通讯不只这一种方式，但这是最基础的</p></div> <h4 id="单项数据流"><a href="#单项数据流" class="header-anchor">#</a> 单项数据流</h4> <p>就像我前面说的，虽然vue也推荐单项数据流，但是react单项数据流做的比vue干净的多，例如vue中为某些UI控件提供了双向数据绑定的方式，而且在子组件可以操作父组件传过来的值，虽然此时父组件的值没有改变等等。
通过父子组件数据交互就能清楚的理解单项数据流了，数据永远是父组件那边来的，子组件只能通知父组件改自己的值，因为父组件改了自己的值从而让子组件数据变化，数据流向从来都是父到子，这种设计的好处也是非常明显的，流向清晰，利于追踪数据等
现在前端三大框架编码主流都是推荐单项数据流</p> <h4 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h4> <p>react里面简直就是函数式编程的生动体现，可以说每一个组件就是一个函数生成等等。
有些人不理解函数式编程，lodash,underscore都是典型的函数式编程</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog.github.io/assets/js/app.bba64067.js" defer></script><script src="/blog.github.io/assets/js/2.bc234928.js" defer></script><script src="/blog.github.io/assets/js/13.51657757.js" defer></script>
  </body>
</html>
