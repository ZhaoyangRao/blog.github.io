<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>多进程多线程的浏览器 | RaoCy blog</title>
    <meta name="description" content="我的博客网站">
    <link rel="icon" href="/blog.github.io/logo.jpg">
    
    <link rel="preload" href="/blog.github.io/assets/css/0.styles.59e117d8.css" as="style"><link rel="preload" href="/blog.github.io/assets/js/app.71936c35.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/2.bc234928.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/14.a8020e59.js" as="script"><link rel="prefetch" href="/blog.github.io/assets/js/10.cbc3757b.js"><link rel="prefetch" href="/blog.github.io/assets/js/11.786dec48.js"><link rel="prefetch" href="/blog.github.io/assets/js/12.fe685913.js"><link rel="prefetch" href="/blog.github.io/assets/js/13.254ab21b.js"><link rel="prefetch" href="/blog.github.io/assets/js/15.4c6dfa50.js"><link rel="prefetch" href="/blog.github.io/assets/js/16.4481b959.js"><link rel="prefetch" href="/blog.github.io/assets/js/17.f6509f4a.js"><link rel="prefetch" href="/blog.github.io/assets/js/18.beb989d0.js"><link rel="prefetch" href="/blog.github.io/assets/js/19.045ec79e.js"><link rel="prefetch" href="/blog.github.io/assets/js/20.d3c2621f.js"><link rel="prefetch" href="/blog.github.io/assets/js/21.a2079b54.js"><link rel="prefetch" href="/blog.github.io/assets/js/3.6d9ef83f.js"><link rel="prefetch" href="/blog.github.io/assets/js/4.11c97c33.js"><link rel="prefetch" href="/blog.github.io/assets/js/5.5ce521ab.js"><link rel="prefetch" href="/blog.github.io/assets/js/6.f3ac795d.js"><link rel="prefetch" href="/blog.github.io/assets/js/7.d274e7ab.js"><link rel="prefetch" href="/blog.github.io/assets/js/8.0ac266c7.js"><link rel="prefetch" href="/blog.github.io/assets/js/9.97b8cebc.js">
    <link rel="stylesheet" href="/blog.github.io/assets/css/0.styles.59e117d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog.github.io/" class="home-link router-link-active"><!----> <span class="site-name">RaoCy blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog.github.io/fontbase/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/blog.github.io/fontup/index/" class="nav-link">前端进阶</a></div><div class="nav-item"><a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></div><div class="nav-item"><a href="/blog.github.io/edit/" class="nav-link">前端开发编辑器</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器工作原理</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog.github.io/fontbase/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/blog.github.io/fontup/index/" class="nav-link">前端进阶</a></div><div class="nav-item"><a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></div><div class="nav-item"><a href="/blog.github.io/edit/" class="nav-link">前端开发编辑器</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器工作原理</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>多进程多线程的浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog.github.io/study/browser.html#多进程多线程的浏览器" class="sidebar-link">多进程多线程的浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.github.io/study/browser.html#多进程" class="sidebar-link">多进程</a></li><li class="sidebar-sub-header"><a href="/blog.github.io/study/browser.html#多线程" class="sidebar-link">多线程</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="多进程多线程的浏览器"><a href="#多进程多线程的浏览器" class="header-anchor">#</a> 多进程多线程的浏览器</h2> <p>作为一名前端工程师，之前对于浏览器的认知还不够深入，翻阅了一系列文章，进行浏览器的逐步分析与学习，加深自己的知识储备。同时这部分知识也是做页面性能优化，等工具时所必须的基础知识。<br>
这里以chrome浏览器举例,chrome浏览器使用的是多进程多线程模式<br></p> <h3 id="多进程"><a href="#多进程" class="header-anchor">#</a> 多进程</h3> <ul><li>浏览器进程 (Browser Process)：负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。<br></li> <li>渲染进程 (Renderer Process)：负责一个Tab内的显示相关的工作，也称渲染引擎。<br></li> <li>插件进程 (Plugin Process)：负责控制网页使用到的插件<br></li> <li>GPU进程 (GPU Process)：负责处理整个应用程序的GPU任务<br></li></ul> <h4 id="浏览器各进程之间的关系"><a href="#浏览器各进程之间的关系" class="header-anchor">#</a> 浏览器各进程之间的关系</h4> <p>首先，当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候Browser Process(浏览器进程)会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给Renderer Process(渲染进程)，Renderer Process(渲染进程)解析HTML内容，解析遇到需要请求网络的资源又返回来交给Browser Process(浏览器进程)进行加载，同时通知Browser Process(浏览器进程)，需要Plugin Process(插件进程)加载插件资源，执行插件代码。解析完成后，Renderer Process(渲染进程)计算得到图像帧，并将这些图像帧交给GPU Process(GPU进程)，GPU Process(GPU进程)将其转化为图像显示屏幕。</p> <h4 id="why多进程？多进程的优势是什么？"><a href="#why多进程？多进程的优势是什么？" class="header-anchor">#</a> why多进程？多进程的优势是什么？</h4> <ul><li>更高的安全性，各进程相互独立，分配单独的内存，单独的执行环境<br></li> <li>更高的容错性,各进程相互独立，避免一个崩溃，全崩溃<br></li> <li>更好的分配性能，避免互相抢资源，单进程的架构中，各个任务相互竞争抢夺CPU资源，使得浏览器响应速度变慢，而多进程架构正好规避了这一缺点<br></li></ul> <h4 id="多进程的劣势"><a href="#多进程的劣势" class="header-anchor">#</a> 多进程的劣势</h4> <p>渲染进程的作用是负责一个Tab内的显示相关的工作，这就意味着，一个Tab，就会有一个渲染进程，这些进程之间的内存无法进行共享，开启一个tab就开启一个进程，这也是为什么浏览器tab开的越多越卡，甚至会崩溃等等，为了优化这一类的弊端，各浏览器都选择了自己的方式去优化内存，也就是进程模式。</p> <h4 id="进程模式"><a href="#进程模式" class="header-anchor">#</a> 进程模式</h4> <p>为了节省内存，Chrome提供了四种进程模式（Process Models），不同的进程模式会对 tab 进程做不同的处理。<br></p> <ul><li>Process-per-site - 同一个 site 使用一个进程<br></li> <li>Process-per-tab - 每个 tab 使用一个进程<br></li> <li>Single process - 所有 tab 共用一个进程 单进程模式<br></li> <li>Process-per-site-instance (default) - 同一个 site-instance 使用一个进程， Chrome 默认使用的模式，相较于 Process-per-tab，能够少开很多进程，就意味着更少的内存占用，相较于 Process-per-site，能够更好的隔离相同域名下毫无关联的 tab，更加安全，兼容了性能与易用性<br></li></ul> <h3 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h3> <p>其实这里的多线程主要是针对浏览器渲染进程来的，也被称为浏览器内核，通过对这些线程的控制来输出可视化的网页或者图像</p> <h4 id="渲染进程-renderer-process-相关线程"><a href="#渲染进程-renderer-process-相关线程" class="header-anchor">#</a> 渲染进程 (Renderer Process)相关线程</h4> <ul><li>GUI线程
负责渲染浏览器界面</li> <li>js引擎线程
负责处理JavaScript脚本程序</li> <li>定时触发器线程
setInterval与setTimeout所在线程</li> <li>事件触发线程
主要用于控制事件（例如鼠标，键盘等事件）</li> <li>异步http请求线程
XMLHttpRequest通过浏览器新开的一个线程请求<br>
浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。<br></li></ul> <p>由于Js是可操纵DOM的，如果存在一个操作dom的行为导致界面的重绘回流，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。<br></p> <p>渲染进程（各线程的相互配合）的主要目标是将html+css+js渲染成开发者预期的UI<br></p> <div class="custom-block tip"><p class="custom-block-title">浏览器的渲染过程</p> <p>渲染进程拿到响应的报文以后，这里不考虑缓存，渲染界面大致的步骤<br>
1.解析html生成DOM TREE<br>
2.解析CSS生成CSS TREE<br>
3.DOM TREE+CSS TREE生成render tree<br>
4.根据render tree来计算各个元素的位置，大小等等，这个过程被称为layout<br>
5.将layout后的render tree进行绘制这个过程被称为Painting<br>
6.GPU进程再将各个图层合成(composite)渲染成开发者预期的UI<br></p> <p>需要注意的是我们前面了解到js引擎线程会让GUI线程挂起，等待JS引擎空闲后执行，所以在渲染的过程中，render tree会被js阻塞，尤其js里面有大量的操作dom的时候又会导致render tree的重绘回流。</p></div> <div class="custom-block tip"><p class="custom-block-title">图层的概念</p> <p>前面提到了图层的合成composite渲染成开发者预期的UI，这里简单的讲一下图层吧<br></p> <h4 id="图层分为普通图层和复合图层"><a href="#图层分为普通图层和复合图层" class="header-anchor">#</a> 图层分为普通图层和复合图层<br></h4> <p>复合图层（单独分配资源，硬件加速，各个复合图层是单独绘制）<br></p> <ul><li>translate3d、translateZ（3D或透视变换）<br></li> <li>video iframe canvas webgl等元素<br></li> <li>z-index在复合成的上面渲染<br></li> <li>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）<br></li> <li>其它，譬如以前的flash插件<br></li></ul></div> <h4 id="浏览器进程-browser-process-相关线程"><a href="#浏览器进程-browser-process-相关线程" class="header-anchor">#</a> 浏览器进程 (Browser Process)相关线程</h4> <ul><li>UI thread：控制浏览器上的按钮及输入框，处理用户的输入啊等等<br></li> <li>network thread：处理网络请求，从网上获取数据；诸如DNS寻址，建立TLS连接等操作，解析HTTP响应， 安全检查，诸如跨域啊400，500等等错误都是报出来的<br></li> <li>storage thread：控制文件等的访问<br></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog.github.io/assets/js/app.71936c35.js" defer></script><script src="/blog.github.io/assets/js/2.bc234928.js" defer></script><script src="/blog.github.io/assets/js/14.a8020e59.js" defer></script>
  </body>
</html>
