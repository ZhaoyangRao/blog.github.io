<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象 | RaoCy</title>
    <meta name="description" content="欢迎来到RaoCy博客">
    <link rel="icon" href="/blog.github.io/images/logo.png">
    
    <link rel="preload" href="/blog.github.io/assets/css/0.styles.59e117d8.css" as="style"><link rel="preload" href="/blog.github.io/assets/js/app.2da11d0d.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/2.bc234928.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/21.aaeb2253.js" as="script"><link rel="prefetch" href="/blog.github.io/assets/js/10.cbc3757b.js"><link rel="prefetch" href="/blog.github.io/assets/js/11.461a49a9.js"><link rel="prefetch" href="/blog.github.io/assets/js/12.3385b74f.js"><link rel="prefetch" href="/blog.github.io/assets/js/13.51657757.js"><link rel="prefetch" href="/blog.github.io/assets/js/14.78b7287b.js"><link rel="prefetch" href="/blog.github.io/assets/js/15.f9853cb0.js"><link rel="prefetch" href="/blog.github.io/assets/js/16.6e08ead8.js"><link rel="prefetch" href="/blog.github.io/assets/js/17.6fc4e508.js"><link rel="prefetch" href="/blog.github.io/assets/js/18.f1fc4e2e.js"><link rel="prefetch" href="/blog.github.io/assets/js/19.c30b2270.js"><link rel="prefetch" href="/blog.github.io/assets/js/20.4b3f44b4.js"><link rel="prefetch" href="/blog.github.io/assets/js/22.9ef54a4f.js"><link rel="prefetch" href="/blog.github.io/assets/js/23.be559c73.js"><link rel="prefetch" href="/blog.github.io/assets/js/24.92409e07.js"><link rel="prefetch" href="/blog.github.io/assets/js/25.26cc4164.js"><link rel="prefetch" href="/blog.github.io/assets/js/26.e7a489c0.js"><link rel="prefetch" href="/blog.github.io/assets/js/27.01baeb15.js"><link rel="prefetch" href="/blog.github.io/assets/js/28.95cee6de.js"><link rel="prefetch" href="/blog.github.io/assets/js/29.0bb888d7.js"><link rel="prefetch" href="/blog.github.io/assets/js/3.365e2b2e.js"><link rel="prefetch" href="/blog.github.io/assets/js/30.50ddbd46.js"><link rel="prefetch" href="/blog.github.io/assets/js/31.231ab842.js"><link rel="prefetch" href="/blog.github.io/assets/js/32.c356e814.js"><link rel="prefetch" href="/blog.github.io/assets/js/33.70b05627.js"><link rel="prefetch" href="/blog.github.io/assets/js/4.11c97c33.js"><link rel="prefetch" href="/blog.github.io/assets/js/5.9be0316a.js"><link rel="prefetch" href="/blog.github.io/assets/js/6.0ab42dfa.js"><link rel="prefetch" href="/blog.github.io/assets/js/7.8a6a298a.js"><link rel="prefetch" href="/blog.github.io/assets/js/8.60a9c72f.js"><link rel="prefetch" href="/blog.github.io/assets/js/9.07c23159.js">
    <link rel="stylesheet" href="/blog.github.io/assets/css/0.styles.59e117d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog.github.io/" class="home-link router-link-active"><!----> <span class="site-name">RaoCy</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面向对象</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog.github.io/study/class.html#封装" class="sidebar-link">封装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.github.io/study/class.html#继承" class="sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.github.io/study/class.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/blog.github.io/study/class.html#继承-2" class="sidebar-link">继承</a></li></ul></li><li><a href="/blog.github.io/study/class.html#多态" class="sidebar-link">多态</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <p>在js里面所有的都可以看作对象，正所谓万物皆对象。</p> <p>面向对象三大特征</p> <ul><li>封装</li> <li>继承</li> <li>多态</li></ul> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h2> <p>其实封装里面有很多知识点，看你怎么去理解，往空泛了说封装就是你封装一个函数或者方法，方便调用，避免写一些重复的代码。
但怎么去封装，就会涉及到你是用函数式编程的方式去编码，还是继承的方式去编码。</p> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>js里面的面向对象其实跟大多数面向对象的编程语言都不一样。
正常的面向对象里面有两个最重要的基本概念</p> <ul><li>类class，类本身就是一种类型，不表示任何具体的实例</li> <li>实例，根据类创建的对象<br></li></ul> <p>而在js里面是通过复制原型来实现继承的</p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>这也是js实现面向对象，继承的最重要的一个概念。</p> <p>js的原型是一个很让人头疼的事情。
<br>一 来prototype容易与proto混淆。
<br>二 来则是prototype、proto和constructor的三角关系。<br></p> <p>接下来我会举一些小例子来解释三者的关系</p> <ul><li>函数才有prototype</li> <li>对象都有proto constructor</li> <li>函数也是对象，所以函数也有proto constructor(以后有机会专门说一下Function 和Object的关系)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>【构造函数】
【实例对象】
例子1
function Foo(){};
var f1 = new Foo;
var f2 = new Foo;
Foo就是构造函数
f1，f2就是实例对象
————————————————————————————————————————————————————————
【prototype】
例子2
function Foo(){};
Foo.prototype.a=1
var f1 = new Foo;
var f2 = new Foo;

console.log(Foo.prototype.a);//1
console.log(f1.a);//1
console.log(f2.a);//1
构造函数都有一个prototype，而new得作用之一是复制构造器得原型，使f1,f2保持了引用，所以其实f1,f2得prototyte对象其实是同一个引用，这就是js实现继承得本质

例子3
function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype); {constructor:f}
console.log(f1.prototype);  //undefined
实例对象并打印不出来prototype，只有构造函数能打印出来，可见在js里面prototype属性只对构造函数暴露出来了
构造函数得prototype属性指向得是constructor，在这里也就是自己
————————————————————————————————————————————————————————
【constructor】
例子4
function Foo(){};
var f1 = new Foo;
console.log(f1.constructor === Foo);//true

constructor（构造器），实例对象得构造器就指向构造函数
我们知道f1这个实例对象其实也通过原型对构造器保持着引用，我们怎么打印出来它的prototype呢，参考例子5
——————————————————————————————————————————————————————————
【proto】
例子5
function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
我们可以看出来，f1的proto就能指向prototype，因为f1是复制的构造函数Foo的prototype，所以他们的prototype是相同的
所以我们可以推出   实例对象的proto指向的是该实例对象的原型
———————————————————————————————————————————————————————————
例子6
function a(){}
console.log(a.__proto__===Function.prototype)

我们可以看出来a虽然并不是new出来的，其实也是一个实例，它的构造函数是Function,只是背后做了这些事情，我们不知道而已
</code></pre></div><p>从上面一大堆例子其实已经可以得出三个之间的关系了</p> <ul><li>函数prototype是实例与构造函数的一种引用，实例对象复制的构造函数的prototype。</li> <li>js里面的继承本质上就是实例去复制构造函数的prototype。</li> <li>函数的proto指向的是其构造函数的prototype,并且可以通过proto一直追诉到顶级，这一层一层的结构就是原型链。</li> <li>函数的constructor指向的就是它的构造器。</li></ul> <p>其实js里面的继承本质上就是一个函数复制了另外一个函数的原型，通过在原型上挂在属性方法，复制的时候就把属性方法一起给复制了，也就实现了继承。
写到这里我也觉得js里面的继承理解起来其实比其他面向对象的继承繁琐多了，谁让我们这门语言就没有类这个概念呢，即使后面es6的class也只是个语法糖。</p> <h3 id="继承-2"><a href="#继承-2" class="header-anchor">#</a> 继承</h3> <h4 id="一-原型链继承"><a href="#一-原型链继承" class="header-anchor">#</a> 一 . 原型链继承</h4> <div class="language- extra-class"><pre class="language-text"><code>function Stu(){
}
Stu.prototype.sex='男'
var a= new Stu();
var b= new Stu();
console.log(a.sex) //男
 
a和b都是构造器Stu的实例对象，构造器上的prototype挂载的属性都被a,b继承
—————————————————————————————————————————————————————
function Stu(){
}
Stu.prototype.sex={
key:'男'
}
var a= new Stu();
var b= new Stu();
a.sex.key='女'
console.log(a.sex.key) //女
console.log(b.sex.key) //女
因为属性sex是引用数据类型，a修改了，b也被修改了
——————————————————————————————————————————————————————
</code></pre></div><p>优点</p> <ul><li>纯粹的继承关系，实例就是构造函数的实例</li> <li>简单</li></ul> <p>缺点</p> <ul><li>无法传参</li> <li>构造器原型对象上的所有属性都会被实例继承，构造函数更改属性，那么实例上所有的属性都会被更改</li> <li>实例继承的属性是引用类型的话，所有实例的属性都会被修改</li> <li>多继承乏力</li></ul> <h4 id="二-构造继承"><a href="#二-构造继承" class="header-anchor">#</a> 二 . 构造继承</h4> <div class="language- extra-class"><pre class="language-text"><code>function Father(param){
    this.name=param
}
function Father2(param){
    this.sex=param
}
function Son(name,sex){
    Father.call(this,name)
    Father2.call(this,sex)
}
var a=new Son('张三','男')
console.log(a);
console.log(a instanceof Son); true
console.log(a instanceof Father); false

a就通过call或者apply实现了继承多个构造函数
—————————————————————————————————————————————————————————

</code></pre></div><p>优点</p> <ul><li>可以传参</li> <li>可以实现多个构造函数的继承</li> <li>实例可以不用完全共享构造函数的属性，更活用</li></ul> <p>缺点</p> <ul><li>实例并不是父类的实例，是子类的实例。（比如上面的例子，a是And的实例，并不是Stu,Boy的实例，call只是改了this的指向）</li> <li>只能继承父类的实例方法，并不能继承原型的属性方法</li> <li>每个子类其实都是父类函数的副本，都是通过call来拷贝的嘛，影响性能（其实我觉得现代浏览器的性能影响不会太大~~）</li></ul> <h4 id="三"><a href="#三" class="header-anchor">#</a> 三 .</h4> <p>组合继承
核心就是原型链继承和构造函数继承的结合，</p> <div class="language- extra-class"><pre class="language-text"><code>function Father(param){
    this.name=param
}
function Son(name){
    Father.call(this,name)
}
Son.prototype=new Father(name)
var a= new Son('张安');
console.log(a);
console.log(a instanceof Father); // true
console.log(a instanceof Son); // true
——————————————————————————————————————————————————————
</code></pre></div><p>优点</p> <ul><li>原型链继承与构造继承的结合，解决了大部分两个单独使用会出现的问题
缺点</li> <li>相对来说，不只是组合继承，包括原型链继承，构造函数继承以及在这两个上面诞生的其他继承其实都是一种hack,代码都挺难维护的，理解也不舒服，编码也不舒服，所以es6诞生了class的方法</li></ul> <h4 id="四-class"><a href="#四-class" class="header-anchor">#</a> 四 . class</h4> <p>其实class诞生就是为了让我们编码更简单，更好维护</p> <p>【class】</p> <div class="language- extra-class"><pre class="language-text"><code>【class】
class Father{
     constructor(name) {
        this.name = name;
    }
    eat(){
        console.log('eat')
    }
}
var a= new Father('张三');
console.log(a)
</code></pre></div><p>就是这么的清爽，简单，你很容易就能理解Father是个类，a是一个实例，代码里面没有任何的什么call啊 prototype啊</p> <div class="language- extra-class"><pre class="language-text"><code>new Foo();// ReferenceError
class Foo{}
</code></pre></div><p>值得注意的是这样会报错，class不存在变量提升</p> <p>【constructor】</p> <div class="language- extra-class"><pre class="language-text"><code>class Father{
    constructor(){}
}
//等同于
Father.prototype = {
    constructor(){},
}

class Point{}
//等同于
class Point{
    constructor(){}
}
</code></pre></div><p>class中的constructor，其实这里的constructor等同于挂载到prototype的constructor
这里其实跟es5所理解的constructor是一致的，只是写法而已。<br>
就算你不写constructor,其实也会默认添加一个空的constructor。</p> <p>【extends】</p> <p>class可以通过extends来实现子类继承父类</p> <div class="language- extra-class"><pre class="language-text"><code>class Father{}
class Son extends Father{}
</code></pre></div><p>【super】</p> <p>super作为函数使用时：</p> <p>其实下面的例子才是一个子类继承父类的基本结构，而且子类必须执行super()</p> <div class="language- extra-class"><pre class="language-text"><code>class A{}
class B extends A{
    constructor(){
        this.name='123' //报错
        super(); //其实这里相当于 A.prototype.constructor.call(this)   
        this.name='123' //对的
    }
}
</code></pre></div><p>简单的理解就是子类要先super一下，代码上看就是 父类.prototype.constructor.call(this)，
得到与父类相同的实例属性和方法，然后再加上子类自己的实例属性和方法。<br>
所以只有调用super之后，才可以使用this关键字，否则会报错</p> <p>super作为对象使用时：</p> <div class="language- extra-class"><pre class="language-text"><code>class A{
     constructor(){
        this.name='123'
     }
    eat(){
        return 'eat'
    }
}
class B extends A{
    constructor(){
       super(); 
       console.log(super.eat()); //eat A.prototype.eat()
       console.log(super.name);  //undefined
       console.log(super.constructor.name) //123
    }
}
var c = new B();
</code></pre></div><p>可以看出,作为对象,super其实就相当于 A.prototype,指向的就是父类的原型对象。作为函数，其实就是把父类的构造器的属性给绑定在this上<br>
从上面的例子还可以看出 super.name取不到值，super.constructor.name是能取到值的，这也间接说明了class这个关键字，其实内部所有的属性都是挂载到prototype上的，constructor 相当于 prototype.constructor。<br>
所以作为代码层面简单的理解就是class除了constructor，其他的属性全是直接挂原型上的，constructor是间接挂原型上的。<br>
站在继承的角度讲，class继承属性和方法分别挂在原型和构造器内部<br>
所有其实class只是一个语法糖，内部依然还是通过prototype实现继承的本质,super就专门去实现this的call，但是class写法让人更好理解，也更好维护。<br></p> <h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <p>其实我以前对多态也不是很理解，看了很多文献博客,不同的文献还总结不同的结果，什么重载啊重写啊例子举一大堆，我大致总结了一下<br>
其实多态就是不同的对象执行同一个操作，返回不同的结果。最简单的例子就是加法运算符，数字跟字符串加法运算的结果大不一样<br>
理念上来说，就是把做什么跟谁去做分开，让代码更好维护 <br></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog.github.io/assets/js/app.2da11d0d.js" defer></script><script src="/blog.github.io/assets/js/2.bc234928.js" defer></script><script src="/blog.github.io/assets/js/21.aaeb2253.js" defer></script>
  </body>
</html>
