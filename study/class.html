<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象 | RaoCy</title>
    <meta name="description" content="欢迎来到RaoCy博客">
    <link rel="icon" href="/blog.github.io/images/logo.png">
    
    <link rel="preload" href="/blog.github.io/assets/css/0.styles.59e117d8.css" as="style"><link rel="preload" href="/blog.github.io/assets/js/app.fa2756ba.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/2.08fb6a77.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/23.2891f3cb.js" as="script"><link rel="prefetch" href="/blog.github.io/assets/js/10.f22ebfd2.js"><link rel="prefetch" href="/blog.github.io/assets/js/11.c234647a.js"><link rel="prefetch" href="/blog.github.io/assets/js/12.11cd38ed.js"><link rel="prefetch" href="/blog.github.io/assets/js/13.beee3256.js"><link rel="prefetch" href="/blog.github.io/assets/js/14.612e31b7.js"><link rel="prefetch" href="/blog.github.io/assets/js/15.00511f46.js"><link rel="prefetch" href="/blog.github.io/assets/js/16.84bcf99b.js"><link rel="prefetch" href="/blog.github.io/assets/js/17.1a599d19.js"><link rel="prefetch" href="/blog.github.io/assets/js/18.30e47f41.js"><link rel="prefetch" href="/blog.github.io/assets/js/19.6cba97f6.js"><link rel="prefetch" href="/blog.github.io/assets/js/20.06c10bc7.js"><link rel="prefetch" href="/blog.github.io/assets/js/21.b2e76090.js"><link rel="prefetch" href="/blog.github.io/assets/js/22.c8f5b237.js"><link rel="prefetch" href="/blog.github.io/assets/js/24.eda369d5.js"><link rel="prefetch" href="/blog.github.io/assets/js/25.8e109bb7.js"><link rel="prefetch" href="/blog.github.io/assets/js/26.9b670c4a.js"><link rel="prefetch" href="/blog.github.io/assets/js/27.518dbe12.js"><link rel="prefetch" href="/blog.github.io/assets/js/28.3f289a1b.js"><link rel="prefetch" href="/blog.github.io/assets/js/29.e5d2970d.js"><link rel="prefetch" href="/blog.github.io/assets/js/3.e1227595.js"><link rel="prefetch" href="/blog.github.io/assets/js/30.c96b9d16.js"><link rel="prefetch" href="/blog.github.io/assets/js/31.c61fff3d.js"><link rel="prefetch" href="/blog.github.io/assets/js/32.457903f2.js"><link rel="prefetch" href="/blog.github.io/assets/js/33.bbbe8e6b.js"><link rel="prefetch" href="/blog.github.io/assets/js/34.a18faace.js"><link rel="prefetch" href="/blog.github.io/assets/js/35.35bb20f9.js"><link rel="prefetch" href="/blog.github.io/assets/js/36.87178d4a.js"><link rel="prefetch" href="/blog.github.io/assets/js/37.19b3528a.js"><link rel="prefetch" href="/blog.github.io/assets/js/38.1fb79f44.js"><link rel="prefetch" href="/blog.github.io/assets/js/39.7b4c5fc7.js"><link rel="prefetch" href="/blog.github.io/assets/js/4.0c40ed64.js"><link rel="prefetch" href="/blog.github.io/assets/js/40.541ac0d4.js"><link rel="prefetch" href="/blog.github.io/assets/js/41.aac81066.js"><link rel="prefetch" href="/blog.github.io/assets/js/5.24bd3210.js"><link rel="prefetch" href="/blog.github.io/assets/js/6.6b979b3c.js"><link rel="prefetch" href="/blog.github.io/assets/js/7.a1080829.js"><link rel="prefetch" href="/blog.github.io/assets/js/8.3f1e94ff.js"><link rel="prefetch" href="/blog.github.io/assets/js/9.fcceb79b.js">
    <link rel="stylesheet" href="/blog.github.io/assets/css/0.styles.59e117d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog.github.io/" class="home-link router-link-active"><!----> <span class="site-name">RaoCy</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端构建工具" class="dropdown-title"><span class="title">前端构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/gulp/" class="nav-link">gulp</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/webworker/" class="nav-link">Web Worker</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iframe/" class="nav-link">iframe</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/http/" class="nav-link">http协议</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/cookie/" class="nav-link">cookie</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端知识点" class="dropdown-title"><span class="title">前端知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/event/" class="nav-link">js里的事件模型</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/module/" class="nav-link">前端模块化规范</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端构建工具" class="dropdown-title"><span class="title">前端构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/gulp/" class="nav-link">gulp</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/webworker/" class="nav-link">Web Worker</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iframe/" class="nav-link">iframe</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/http/" class="nav-link">http协议</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/cookie/" class="nav-link">cookie</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端知识点" class="dropdown-title"><span class="title">前端知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/event/" class="nav-link">js里的事件模型</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/module/" class="nav-link">前端模块化规范</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面向对象</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog.github.io/study/class.html#封装" class="sidebar-link">封装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog.github.io/study/class.html#继承" class="sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.github.io/study/class.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/blog.github.io/study/class.html#继承-2" class="sidebar-link">继承</a></li></ul></li><li><a href="/blog.github.io/study/class.html#多态" class="sidebar-link">多态</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h1> <p>在js里面所有的都可以看作对象，正所谓万物皆对象。</p> <p>面向对象三大特征</p> <ul><li>封装</li> <li>继承</li> <li>多态</li></ul> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h2> <p>其实封装里面有很多知识点，看你怎么去理解，往空泛了说封装就是你封装一个函数或者方法，方便调用，避免写一些重复的代码。
但怎么去封装，就会涉及到你是用函数式编程的方式去编码，还是继承的方式去编码。</p> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>js里面的面向对象其实跟大多数面向对象的编程语言都不一样。
正常的面向对象里面有两个最重要的基本概念</p> <ul><li>类class，类本身就是一种类型，不表示任何具体的实例</li> <li>实例，根据类创建的对象<br></li></ul> <p>而在js里面是通过复制原型来实现继承的</p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>这也是js实现面向对象，继承的最重要的一个概念。</p> <p>js的原型是一个很让人头疼的事情。
<br>一 来prototype容易与proto混淆。
<br>二 来则是prototype、proto和constructor的三角关系。<br></p> <p>接下来我会举一些小例子来解释三者的关系</p> <ul><li>函数才有prototype</li> <li>对象都有proto constructor</li> <li>函数也是对象，所以函数也有proto constructor(以后有机会专门说一下Function 和Object的关系)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>【构造函数】
【实例对象】
例子1
function Foo(){};
var f1 = new Foo;
var f2 = new Foo;
Foo就是构造函数
f1，f2就是实例对象
————————————————————————————————————————————————————————
【prototype】
例子2
function Foo(){};
Foo.prototype.a=1
var f1 = new Foo;
var f2 = new Foo;

console.log(Foo.prototype.a);//1
console.log(f1.a);//1
console.log(f2.a);//1
构造函数都有一个prototype，而new得作用之一是复制构造器得原型，使f1,f2保持了引用，
所以其实f1,f2得prototyte对象其实是同一个引用，这就是js实现继承得本质

例子3
function Foo(){};
var f1 = new Foo;
console.log(Foo.prototype); {constructor:f}
console.log(f1.prototype);  //undefined
实例对象并打印不出来prototype，只有构造函数能打印出来，
可见在js里面prototype属性只对构造函数暴露出来了
构造函数得prototype属性指向的是constructor
————————————————————————————————————————————————————————
【constructor】
例子4
function Foo(){};
var f1 = new Foo;
console.log(f1.constructor === Foo);//true

constructor（构造器），实例对象得构造器就指向构造函数
我们知道f1这个实例对象其实也通过原型对构造器保持着引用，我们怎么打印出来它的prototype呢，参考例子5
——————————————————————————————————————————————————————————
【proto】
例子5
function Foo(){};
var f1 = new Foo;
console.log(f1.__proto__ === Foo.prototype);//true
我们可以看出来，f1的proto就能指向prototype，因为f1是复制的构造函数Foo的prototype，
所以他们的prototype是相同的
所以我们可以推出   实例对象的proto指向的是该实例对象的原型
———————————————————————————————————————————————————————————
例子6
function a(){}
console.log(a.__proto__===Function.prototype)

我们可以看出来a虽然并不是我们显示的new出来的，其实也是一个实例，
它的构造函数是Function,只是背后做了这些事情，我们不知道而已
</code></pre></div><p>从上面一大堆例子其实已经可以得出三个之间的关系了</p> <ul><li>prototype是实例与构造函数的一种引用。</li> <li>js里面的继承本质上就是实例去复制构造函数的prototype。</li> <li>函数的proto指向的是其构造函数的prototype,并且可以通过proto一直追诉到顶级，这一层一层的结构就是原型链。</li> <li>实例的constructor指向的就是它的构造函数。</li></ul> <p>其实js里面的继承本质上就是一个函数复制了另外一个函数的原型，通过在原型上挂在属性方法，复制的时候就把属性方法一起给复制了，也就实现了继承。<br>
写到这里我也觉得js里面的继承理解起来其实比其他面向对象的继承繁琐多了，谁让我们这门语言就没有类这个概念呢，即使后面es6的class也只是个语法糖。</p> <h3 id="继承-2"><a href="#继承-2" class="header-anchor">#</a> 继承</h3> <h4 id="一-原型链继承"><a href="#一-原型链继承" class="header-anchor">#</a> 一 . 原型链继承</h4> <div class="language- extra-class"><pre class="language-text"><code>function Stu(){
}
Stu.prototype.sex='男'
var a= new Stu();
var b= new Stu();
console.log(a.sex) //男
 
a和b都是构造器Stu的实例对象，构造器上的prototype挂载的属性都被a,b继承
—————————————————————————————————————————————————————
function Stu(){
}
Stu.prototype.sex={
key:'男'
}
var a= new Stu();
var b= new Stu();
a.sex.key='女'
console.log(a.sex.key) //女
console.log(b.sex.key) //女
因为属性sex是引用数据类型，a修改了，b也被修改了
——————————————————————————————————————————————————————
</code></pre></div><p>优点</p> <ul><li>纯粹的继承关系，实例就是构造函数的实例</li> <li>简单</li></ul> <p>缺点</p> <ul><li>无法传参</li> <li>构造器原型对象上的所有属性都会被实例继承，构造函数更改属性，那么实例上所有的属性都会被更改</li> <li>实例继承的属性是引用类型的话，所有实例的属性都会被修改</li> <li>多继承乏力</li></ul> <h4 id="二-构造继承"><a href="#二-构造继承" class="header-anchor">#</a> 二 . 构造继承</h4> <div class="language- extra-class"><pre class="language-text"><code>function Father(param){
    this.name=param
}
function Father2(param){
    this.sex=param
}
function Son(name,sex){
    Father.call(this,name)
    Father2.call(this,sex)
}
var a=new Son('张三','男')
console.log(a);
console.log(a instanceof Son); true
console.log(a instanceof Father); false

a就通过call或者apply实现了继承多个构造函数
—————————————————————————————————————————————————————————

</code></pre></div><p>优点</p> <ul><li>可以传参</li> <li>可以实现多个构造函数的继承</li> <li>实例可以不用完全共享构造函数的属性，更活用</li></ul> <p>缺点</p> <ul><li>实例并不是父类的实例，是子类的实例。（比如上面的例子，a是Son的实例，并不是Father,Father2的实例，call只是改了this的指向）</li> <li>只能继承父类的实例方法，并不能继承挂载到父类原型上的属性方法（比如Father.prototype上的属性方法）</li> <li>每个子类其实都是父类函数的副本，都是通过call来拷贝的嘛，影响性能（其实我觉得现代浏览器的性能影响不会太大~~）</li></ul> <h4 id="三-组合继承"><a href="#三-组合继承" class="header-anchor">#</a> 三 . 组合继承</h4> <p>核心思想就是原型链继承和构造函数继承的结合起来</p> <div class="language- extra-class"><pre class="language-text"><code>function Father(param){
    this.name=param
}
function Son(name){
    Father.call(this,name)
}
Son.prototype=new Father(name)；//相当于把父类Father的原型赋值给了子类Son的原型,
var a= new Son('张安');
console.log(a);
console.log(a instanceof Father); // true
console.log(a instanceof Son); // true
——————————————————————————————————————————————————————
</code></pre></div><p>优点</p> <ul><li>原型链继承与构造继承的结合，解决了大部分两个单独使用会出现的问题
缺点</li> <li>相对来说，不只是组合继承，包括原型链继承，构造函数继承以及在这两个上面诞生的其他继承其实都是一种hack,理解也不舒服，编码也不舒服，维护起来更不舒服，所以es6诞生了class的方法</li></ul> <h4 id="四-class"><a href="#四-class" class="header-anchor">#</a> 四 . class</h4> <p>其实class诞生就是为了让我们编码更简单，更好维护</p> <p>【class】</p> <div class="language- extra-class"><pre class="language-text"><code>【class】
class Father{
     constructor(name) {
        this.name = name;   
    }
    eat(){
        console.log('eat')
    }
}
等同于
Father.prototype ={
    constructor(name) {
            this.name = name;   
        }
    eat(){
            console.log('eat')
        }
}


var a= new Father('张三');
console.log(a)
</code></pre></div><p>就是这么的清爽，简单，你很容易就能理解Father是个类，a是一个实例，代码里面没有任何的什么call啊 prototype啊<br></p> <ul><li>定义一个类，它的本质就是一个函数，类本身就指向一个构造函数</li> <li>类里面的所有方法其实都定义在prototype上面，所以其实这个类的实例上调用方法，实际上是调用原型上的方法</li> <li>所以js里面的类其实就是一个语法糖，具体还是使用prototype和this来进行模拟类（具体表现在类里面的constructor构造函数，使用的是constructor构造函数来模拟类，看起来像类的样子）。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>new Foo();// ReferenceError
class Foo{}
</code></pre></div><p>值得注意的是这样会报错，class不存在变量提升</p> <p>【constructor】</p> <div class="language- extra-class"><pre class="language-text"><code>class Father{
    constructor(){}
}
//等同于
Father.prototype = {
    constructor(){},
}

class Point{}
//等同于
class Point{
    constructor(){}
}
</code></pre></div><ul><li>与java很像，每一个类里面就有一个构造函数</li> <li>如果没有显式定义，则会生成一个默认构造函数。</li> <li>constructor方法默认返回实例对象this，也可以return另外一个对象</li> <li>class中的constructor函数，其实这里的constructor函数等同于挂载到prototype的constructor</li></ul> <p>值得注意的是，我们知道其实本质上js里面的类本身就是一个构造函数，类里面的方法都是挂载到原型上的，所以其实类里面的constructor方法也只是挂载到原型上的一个特殊一点的方法而已</p> <p>【extends】</p> <p>class可以通过extends来实现子类继承父类</p> <div class="language- extra-class"><pre class="language-text"><code>class Father{}
class Son extends Father{}
</code></pre></div><p>【super】</p> <p>super作为函数使用时：</p> <p>其实下面的例子才是一个子类继承父类的基本结构，而且子类必须执行super()</p> <div class="language- extra-class"><pre class="language-text"><code>class A{}
class B extends A{
    constructor(){
        this.name='123' //报错
        super(); //其实这里相当于 A.prototype.constructor.call(this)   
        this.name='123' //对的
    }
}
</code></pre></div><p>简单的理解就是子类要先super一下，代码上看就是 父类.prototype.constructor.call(this)，
得到与父类相同的实例属性和方法，然后再加上子类自己的实例属性和方法。<br>
所以只有调用super之后，才可以使用this关键字，否则会报错</p> <p>super作为对象使用时：</p> <div class="language- extra-class"><pre class="language-text"><code>class A{
     constructor(){
        this.name='123'
     }
    eat(){
        return 'eat'
    }
}
class B extends A{
    constructor(){
       super(); 
       console.log(super.eat()); //eat A.prototype.eat()
       console.log(super.name);  //undefined
       console.log(super.constructor.name) //123
    }
}
var c = new B();
</code></pre></div><p>可以看出,作为对象,super其实就相当于 A.prototype,指向的就是父类的原型对象。作为函数，其实就是把父类的构造器的属性给绑定在this上<br></p> <p>从上面的例子还可以看出 super.name取不到值，super.constructor.name是能取到值的，这也间接说明了class这个关键字，其实内部所有的属性都是挂载到prototype上的，constructor 相当于 prototype.constructor。<br></p> <p>所有其实class只是一个语法糖，内部依然还是通过prototype实现继承的本质,super就专门去实现this的call，但是class写法让人更好理解，也更好维护。<br></p> <h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <p>其实我以前对多态也不是很理解，看了很多文献博客,不同的文献还总结不同的结果，什么重载啊重写啊例子举一大堆，我大致总结了一下<br>
其实多态就是不同的对象执行同一个操作，返回不同的结果。最简单的例子就是加法运算符，’两个数字相加‘ 与 ’两个字符串相加‘ 运算的结果大不一样<br>
理念上来说，就是把做什么跟谁去做分开，让代码更好维护 <br></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog.github.io/assets/js/app.fa2756ba.js" defer></script><script src="/blog.github.io/assets/js/2.08fb6a77.js" defer></script><script src="/blog.github.io/assets/js/23.2891f3cb.js" defer></script>
  </body>
</html>
