<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>diff算法 | RaoCy</title>
    <meta name="description" content="欢迎来到RaoCy博客">
    <link rel="icon" href="/blog.github.io/images/logo.png">
    
    <link rel="preload" href="/blog.github.io/assets/css/0.styles.59e117d8.css" as="style"><link rel="preload" href="/blog.github.io/assets/js/app.2da11d0d.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/2.bc234928.js" as="script"><link rel="preload" href="/blog.github.io/assets/js/23.be559c73.js" as="script"><link rel="prefetch" href="/blog.github.io/assets/js/10.cbc3757b.js"><link rel="prefetch" href="/blog.github.io/assets/js/11.461a49a9.js"><link rel="prefetch" href="/blog.github.io/assets/js/12.3385b74f.js"><link rel="prefetch" href="/blog.github.io/assets/js/13.51657757.js"><link rel="prefetch" href="/blog.github.io/assets/js/14.78b7287b.js"><link rel="prefetch" href="/blog.github.io/assets/js/15.f9853cb0.js"><link rel="prefetch" href="/blog.github.io/assets/js/16.6e08ead8.js"><link rel="prefetch" href="/blog.github.io/assets/js/17.6fc4e508.js"><link rel="prefetch" href="/blog.github.io/assets/js/18.f1fc4e2e.js"><link rel="prefetch" href="/blog.github.io/assets/js/19.c30b2270.js"><link rel="prefetch" href="/blog.github.io/assets/js/20.4b3f44b4.js"><link rel="prefetch" href="/blog.github.io/assets/js/21.aaeb2253.js"><link rel="prefetch" href="/blog.github.io/assets/js/22.9ef54a4f.js"><link rel="prefetch" href="/blog.github.io/assets/js/24.92409e07.js"><link rel="prefetch" href="/blog.github.io/assets/js/25.26cc4164.js"><link rel="prefetch" href="/blog.github.io/assets/js/26.e7a489c0.js"><link rel="prefetch" href="/blog.github.io/assets/js/27.01baeb15.js"><link rel="prefetch" href="/blog.github.io/assets/js/28.95cee6de.js"><link rel="prefetch" href="/blog.github.io/assets/js/29.0bb888d7.js"><link rel="prefetch" href="/blog.github.io/assets/js/3.365e2b2e.js"><link rel="prefetch" href="/blog.github.io/assets/js/30.50ddbd46.js"><link rel="prefetch" href="/blog.github.io/assets/js/31.231ab842.js"><link rel="prefetch" href="/blog.github.io/assets/js/32.c356e814.js"><link rel="prefetch" href="/blog.github.io/assets/js/33.70b05627.js"><link rel="prefetch" href="/blog.github.io/assets/js/4.11c97c33.js"><link rel="prefetch" href="/blog.github.io/assets/js/5.9be0316a.js"><link rel="prefetch" href="/blog.github.io/assets/js/6.0ab42dfa.js"><link rel="prefetch" href="/blog.github.io/assets/js/7.8a6a298a.js"><link rel="prefetch" href="/blog.github.io/assets/js/8.60a9c72f.js"><link rel="prefetch" href="/blog.github.io/assets/js/9.07c23159.js">
    <link rel="stylesheet" href="/blog.github.io/assets/css/0.styles.59e117d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog.github.io/" class="home-link router-link-active"><!----> <span class="site-name">RaoCy</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="浏览器的世界" class="dropdown-title"><span class="title">浏览器的世界</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserKey/" class="nav-link">浏览器内核</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browser/" class="nav-link">浏览器多线程多进程</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserOpen/" class="nav-link">浏览器同域名请求并发限制</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserDns/" class="nav-link">浏览器DNS域名解析</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/broeweSafe/" class="nav-link">浏览器的安全</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/browserCache/" class="nav-link">浏览器的缓存</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端杂谈" class="dropdown-title"><span class="title">前端杂谈</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/modules/" class="nav-link">前端开发模式</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/utils/" class="nav-link">常用工具函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/edit/" class="nav-link">前端常用开发工具</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/jsnull/" class="nav-link">null与undefined</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/eventLoop/" class="nav-link">宏任务和微任务</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/callback/" class="nav-link">js异步编程方案</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/iterable/" class="nav-link">iterator迭代器</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/closure/" class="nav-link">闭包</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/funcHigh/" class="nav-link">高阶函数</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/this/" class="nav-link">js中的this</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/class/" class="nav-link">js中的面向对象</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/study/diff/" class="nav-link">diff算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端技术杂玩" class="dropdown-title"><span class="title">前端技术杂玩</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog.github.io/react/index/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mongodb/api/" class="nav-link">mongodb</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/vuecli/index/" class="nav-link">vuecli</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/mxgraph/index/" class="nav-link">mxgraph</a></li><li class="dropdown-item"><!----> <a href="/blog.github.io/prerender-spa-plugin/index/" class="nav-link">prerender-spa-plugin</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>diff算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog.github.io/study/diff.html#diff算法" class="sidebar-link">diff算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog.github.io/study/diff.html#传统的diff算法" class="sidebar-link">传统的diff算法</a></li><li class="sidebar-sub-header"><a href="/blog.github.io/study/diff.html#vue中的diff算法" class="sidebar-link">vue中的diff算法</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <p>diff算法是用来干什么事情的？顾名思义就是来比较不同的算法，diff不就是different的缩写嘛。</p> <p>对于前端来讲，大部分diff算法作用主要还是用来比较两颗DOM树的不同，尤其现在的前端框架例如vue react，也就是虚拟树(Virtual DOM)和真实树(Actual DOM)的不同</p> <h3 id="传统的diff算法"><a href="#传统的diff算法" class="header-anchor">#</a> 传统的diff算法</h3> <p>传统的diff算法比较两个树形结构，通过循环递归对所有的节点进行比较操作，算法的复杂度为O(n3)，n为树节点的总算。<br>
为什么是n3呢？<br>
同一级比较O(n1)，跨级比较O(n2)，最后还要根据前面比较出来的差异计算出最小的转换方式O(n3)，简单的1000个节点，都需要达到10亿次的比较，传统的diff无法直接用在前端框架中，所以react vue等对diff算法进行了优化，使其复杂度降低到O(n1)</p> <h3 id="vue中的diff算法"><a href="#vue中的diff算法" class="header-anchor">#</a> vue中的diff算法</h3> <p>传统的diff算法消耗这么大，vue到底是如何降低复杂度的呢？<br>
最重要的就是vue只进行同级比较，忽略跨级操作，自然而然的没有传统diff里面的跨级比较以及根据同级跨级差异计算最小转换方式的计算了。<br></p> <p>那么同级操作是如何实现diff的呢？<br></p> <h4 id="虚拟节点"><a href="#虚拟节点" class="header-anchor">#</a> 虚拟节点</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;v&quot; class=&quot;classA&quot;&gt;&lt;div&gt; 对应的 Vnode 就是

{
  el:  div  //对真实的节点的引用，本例中就是document.querySelector('#id.classA')
  tagName: 'DIV',   //节点的标签
  sel: 'div#v.classA'  //节点的选择器
  data: null,       // 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style
  children: [], //存储子节点的数组，每个子节点也是vnode结构
  text: null,    //如果是文本节点，对应文本节点的textContent，否则为null
}
</code></pre></div><h4 id="patch"><a href="#patch" class="header-anchor">#</a> patch</h4> <p>diff回调用patch函数，patch接收两个参数vnode，oldVnode</p> <div class="language- extra-class"><pre class="language-text"><code>function patch (oldVnode, vnode) {
    //用来判断是不是同样类型的节点
    if (sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode)
    } else {
    //不同类型的节点，直接走else，走插入，删除节点的操作
        const oEl = oldVnode.el
        let parentEle = api.parentNode(oEl)
        createEle(vnode)
        if (parentEle !== null) {
            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))
            api.removeChild(parentEle, oldVnode.el)
            oldVnode = null
        }
    }
    return vnode
}

function sameVnode(oldVnode, vnode){
   //两节点key值相同，并且sel属性值相同，即认为两节点属同一类型，可进行下一步比较
    return vnode.key === oldVnode.key &amp;&amp; vnode.sel === oldVnode.sel
}
</code></pre></div><p>从上面的代码可以看出，patch函数内第一个if判断sameVnode(oldVnode, vnode)用来判断是不是同样类型的节点，只要节点的key和sel属性值不同，sameVnode就返回false，就认为是不同类型的节点，直接走else，走插入删除节点的操作。<br></p> <p>sel属性我们可以看到 'sel': 'div#v.classA' 其实就是描述这个节点的dom类型，包括class等，很好理解不同的话肯定就是不同的节点。<br></p> <p>key对于vue的特殊之处就可以明显的感觉到了，这也是为什么vue的key如此重要，它是会影响到算法来判断sameVnode是不是相同节点的一个重要标志。<br></p> <h4 id="patchvnode"><a href="#patchvnode" class="header-anchor">#</a> patchVnode</h4> <p>从patch函数中可以看到，如果被vue的sameVnode判断为相同节点的会走patchVnode(oldVnode, vnode)函数。</p> <p>其实这个代码块主要是来判断新旧节点的子节点的情况的，根据新旧节点子节点的各种异同情况走不同的处理。尤其都有子节点，且子节点都不相同的情况会走另外一个重要的函数updateChildren。</p> <div class="language- extra-class"><pre class="language-text"><code>patchVnode (oldVnode, vnode) {
    const el = vnode.el = oldVnode.el  //很重要的一步让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化。
    let i, oldCh = oldVnode.children, ch = vnode.children
    if (oldVnode === vnode) return  //新旧节点的引用一致，认为没有变化，就不做任何操作
   
    if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) {
     //新旧节点文本节点的比较，如果不同就set新节点的文本
        api.setTextContent(el, vnode.text)
    }else {
        updateEle(el, vnode, oldVnode)     
        if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) {
            //新旧节点都有子节点，并且比较了一下还不相同就调用updateChildren
            updateChildren(el, oldCh, ch)
        }else if (ch){  
            //只有新节点有子节点，添加新的子节点
            createEle(vnode) 
        }else if (oldCh){  
            //只有旧节点内存在子节点，执行删除old子节点操作
            api.removeChildren(el)
        }
    }
}
</code></pre></div><h4 id="updatechildren"><a href="#updatechildren" class="header-anchor">#</a> updateChildren</h4> <p>当新旧节点都有子节点，并且还都不相同就会进入updateChildren这个函数</p> <div class="language- extra-class"><pre class="language-text"><code>updateChildren (parentElm, oldCh, newCh) {
    let oldStartIdx = 0, newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx
    let idxInOld
    let elmToMove
    let before
    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
            if (oldStartVnode == null) {   //对于vnode.key的比较，会把oldVnode = null
                oldStartVnode = oldCh[++oldStartIdx] 
            }else if (oldEndVnode == null) {
                oldEndVnode = oldCh[--oldEndIdx]
            }else if (newStartVnode == null) {
                newStartVnode = newCh[++newStartIdx]
            }else if (newEndVnode == null) {
                newEndVnode = newCh[--newEndIdx]
            }else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode)
                oldStartVnode = oldCh[++oldStartIdx]
                newStartVnode = newCh[++newStartIdx]
            }else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode)
                oldEndVnode = oldCh[--oldEndIdx]
                newEndVnode = newCh[--newEndIdx]
            }else if (sameVnode(oldStartVnode, newEndVnode)) {
                patchVnode(oldStartVnode, newEndVnode)
                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))
                oldStartVnode = oldCh[++oldStartIdx]
                newEndVnode = newCh[--newEndIdx]
            }else if (sameVnode(oldEndVnode, newStartVnode)) {
                patchVnode(oldEndVnode, newStartVnode)
                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)
                oldEndVnode = oldCh[--oldEndIdx]
                newStartVnode = newCh[++newStartIdx]
            }else {
               // 使用key时的比较
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表
                }
                idxInOld = oldKeyToIdx[newStartVnode.key]
                if (!idxInOld) {
                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                    newStartVnode = newCh[++newStartIdx]
                }
                else {
                    elmToMove = oldCh[idxInOld]
                    if (elmToMove.sel !== newStartVnode.sel) {
                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)
                    }else {
                        patchVnode(elmToMove, newStartVnode)
                        oldCh[idxInOld] = null
                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)
                    }
                    newStartVnode = newCh[++newStartIdx]
                }
            }
        }
        if (oldStartIdx &gt; oldEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
        }else if (newStartIdx &gt; newEndIdx) {
            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
        }
}
</code></pre></div><p>上面的代码粗略看一眼，你会看到很多熟悉的关键函数patchVnode，sameVnode，addVnodes，removeVnodes，insertBefore还有一些关键的变量oldStartIdx，oldEndIdx，oldEndVnode，oldStartVnode。<br>
其实具体的行为就是由两端至中间的对比，移动，删除，插入。具体的节点还分为有key和无key的情况<br></p> <p>无key的时候，b即使旧节点有相同的也不会复用，而是直接创建新的，删除旧的<br></p> <p><img src="/images/diff01.png" alt="avatar"></p> <p>有key的时候，b会得到复用</p> <p><img src="/images/diff02.png" alt="avatar"></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog.github.io/assets/js/app.2da11d0d.js" defer></script><script src="/blog.github.io/assets/js/2.bc234928.js" defer></script><script src="/blog.github.io/assets/js/23.be559c73.js" defer></script>
  </body>
</html>
